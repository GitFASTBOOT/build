{
  "comments": [
    {
      "key": {
        "uuid": "a37b02ac_290c35bf",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 14,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2015-03-26T23:48:34Z",
      "side": 1,
      "message": "by default, yes, but there\u0027s no actual requirement that you have a guard page. http://pubs.opengroup.org/stage7tc1/functions/pthread_attr_getguardsize.html",
      "revId": "0ae75c3012eb6ddb62ebd0dd7c7edfe98c85a6a9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "63758ab8_4d4c1d4f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 14,
      "author": {
        "id": 1003966
      },
      "writtenOn": "2015-03-26T23:50:45Z",
      "side": 1,
      "message": "Can bionic ensure there\u0027s always a guard page? This is pretty important....",
      "parentUuid": "a37b02ac_290c35bf",
      "revId": "0ae75c3012eb6ddb62ebd0dd7c7edfe98c85a6a9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "43d246e8_3761370e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 14,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2015-03-26T23:55:20Z",
      "side": 1,
      "message": "POSIX says no: \"If guardsize is zero, a guard area shall not be provided for threads created with attr.\"\n\nbut that\u0027s not your real enemy. your real enemy is pthread_attr_setstack (http://pubs.opengroup.org/stage7tc1/functions/pthread_attr_getstack.html#). in that case, the caller allocated the stack, and we can\u0027t go around calling mprotect on memory they gave us. (especially not because they probably sized it deliberately and assume they can use it all.)",
      "parentUuid": "63758ab8_4d4c1d4f",
      "revId": "0ae75c3012eb6ddb62ebd0dd7c7edfe98c85a6a9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "43d246e8_d7222bcd",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 14,
      "author": {
        "id": 1069238
      },
      "writtenOn": "2015-03-26T23:55:28Z",
      "side": 1,
      "message": "If you disable the guard page you lose the guarantee that this will trigger a segmentation fault. The one byte probe write can\u0027t really cause any additional harm if the guard page is missing though. The thread is going to clobber a bunch of stuff with or without this if you do overflow.",
      "parentUuid": "a37b02ac_290c35bf",
      "revId": "0ae75c3012eb6ddb62ebd0dd7c7edfe98c85a6a9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "63758ab8_0dadc514",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 14,
      "author": {
        "id": 1069238
      },
      "writtenOn": "2015-03-27T00:00:36Z",
      "side": 1,
      "message": "One way to make exploitation harder even if there\u0027s no guard page would be to add weak secondary stack ASLR in Bionic. The problem with that is it can screw over callers with very precisely sized stacks, as they\u0027ll have less available than they expect.\n\nUsing a single page for ASLR with stacks \u003e\u003d 1M is arguably sane because they could be screwed over by a compiler update if they\u0027re that close to the end...\n\nI have a patch doing this but it\u0027s pretty sketchy so I didn\u0027t have plans to upstream it.",
      "parentUuid": "43d246e8_d7222bcd",
      "revId": "0ae75c3012eb6ddb62ebd0dd7c7edfe98c85a6a9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}