{
  "comments": [
    {
      "key": {
        "uuid": "495be167_224802be",
        "filename": "core/Makefile",
        "patchSetId": 2
      },
      "lineNbr": 2373,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-01-23T00:54:36Z",
      "side": 1,
      "message": "would have added one but didn\u0027t consider that the other dependencies were also broken :)",
      "range": {
        "startLine": 2373,
        "startChar": 4,
        "endLine": 2373,
        "endChar": 25
      },
      "revId": "4b371e2f2d28358e7b4bb78ac2a4f9f52b4682e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ecc886b0_b8e29dcc",
        "filename": "core/Makefile",
        "patchSetId": 2
      },
      "lineNbr": 2636,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2018-01-23T19:05:06Z",
      "side": 1,
      "message": "AFAIK this file will go through the OTA server and eventually received by android.os.VintfObject.verify, which cannot distinguish a device manifest from vendor and from ODM. Maybe we need a tag for ODM manifests (type\u003d\"odm\"?). Tao, what is this file for?",
      "range": {
        "startLine": 2634,
        "startChar": 0,
        "endLine": 2636,
        "endChar": 5
      },
      "revId": "4b371e2f2d28358e7b4bb78ac2a4f9f52b4682e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "61d03aeb_6664bacc",
        "filename": "core/Makefile",
        "patchSetId": 2
      },
      "lineNbr": 2636,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-01-23T19:07:50Z",
      "side": 1,
      "message": "It\u0027s tagged by name. Honestly, I think we should build files here in the same structure that they are built on actual Android devices. OTA servers should and could then use libvintf directly to check these files.\n\nAs far as a tag specifically for the odm manifest, I say, no way. It\u0027s already distinguished by location. Further identification makes it hard to move manifests, makes them more specialized, etc..., and I\u0027m already not a big fan of \u0027device\u0027 vs \u0027framework\u0027.",
      "parentUuid": "ecc886b0_b8e29dcc",
      "range": {
        "startLine": 2634,
        "startChar": 0,
        "endLine": 2636,
        "endChar": 5
      },
      "revId": "4b371e2f2d28358e7b4bb78ac2a4f9f52b4682e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3d9674f3_3e26a8be",
        "filename": "core/Makefile",
        "patchSetId": 2
      },
      "lineNbr": 2636,
      "author": {
        "id": 1056365
      },
      "writtenOn": "2018-01-24T15:11:07Z",
      "side": 1,
      "message": "\u003e Tao, what is this file for?\n\nDoes \"this file\" mean the \"target-files.zip\" these lines are writing to? If so, this \"target-files.zip\" is the \"input file\" to the OTA generation script. One \"target-files.zip\" corresponds to a build.\n\nThat being said, this CL alone will only pack this odm_manifest.xml into target-files.zip. It won\u0027t show up in an OTA package, or be used in the call to android.os.VintfObject.verify, unless we make matching changes to OTA generation script (build/make/tools/releasetools).\n\nWith the current implementation (https://cs.corp.google.com/android/frameworks/base/core/java/android/os/RecoverySystem.java?q\u003dRecoverySystem.verifyPackage\u0026sq\u003dpackage:android\u0026l\u003d373), the filenames will be lost when calling android.os.VintfObject.verify. We\u0027re passing the file contents.\n\n\u003e OTA servers should and could then use libvintf directly to check these files.\n\nNot sure if the idea is to generate the files based on the runtime info reported from a device. Currently OTA packages are generated offline. The script does some trivial work by packaging these XMLs into an OTA package, without considering any device runtime info. It\u0027s fine to pack additional stuff or to change the files that go into \"target-files.zip\", as long as we have matching changes to the releasetools script, or a host tool to assemble these files together to get the compatibility.zip entry at OTA generation time.\n\nIf the goal is to generate OTA packages dynamically based on device runtime info, there would be quite a few blockers to reach there. For example there\u0027re package signing issues, or device identification issue (we still use a single fingerprint to identify a device and to deliver an OTA) and etc.",
      "parentUuid": "61d03aeb_6664bacc",
      "range": {
        "startLine": 2634,
        "startChar": 0,
        "endLine": 2636,
        "endChar": 5
      },
      "revId": "4b371e2f2d28358e7b4bb78ac2a4f9f52b4682e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "30da7df9_cd350446",
        "filename": "core/Makefile",
        "patchSetId": 2
      },
      "lineNbr": 2636,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2018-01-24T18:52:33Z",
      "side": 1,
      "message": "Thanks for the clarification!",
      "parentUuid": "3d9674f3_3e26a8be",
      "range": {
        "startLine": 2634,
        "startChar": 0,
        "endLine": 2636,
        "endChar": 5
      },
      "revId": "4b371e2f2d28358e7b4bb78ac2a4f9f52b4682e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}