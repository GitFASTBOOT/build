{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "ffabec3b_c84cb971",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1060959
      },
      "writtenOn": "2023-11-07T11:48:30Z",
      "side": 1,
      "message": "Hi Kevin! Thanks for the contribution, seem like a sensible split to have IMO. It\u0027s been a few years since I worked on this stuff so I think Cole will have to review the code changes. IIUC both the existing macros would continue to function exactly as they do today?\n\nI\u0027ll kick off presubmit to make sure we don\u0027t break the \"happy case\". I feel we\u0027d ideally want to do some manual testing of the unhappy case as well (ensure the build breaks if regressions are added into the _system files). It\u0027s a little annoying how difficult it is to have automated testing in Make to instill some confidence in this artifact-path stuff.",
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d17af274_b76671ec",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1535516
      },
      "writtenOn": "2023-11-07T18:03:31Z",
      "side": 1,
      "message": "I can review it, but I don\u0027t really like the artifact path requirements to begin with. They\u0027re extremely confusing errors to most people, and most of the time they have no recourse to fix them other than adding an exception for certain paths. It\u0027s also not really clear _why_ we care about certain makefiles owning certain paths.\n\nThere are also bugs that allow you to circumvent artifact path requirements, like b/299166571. And again, fixing those bugs means adding a bunch of exceptions for the existing violations.",
      "parentUuid": "ffabec3b_c84cb971",
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cb46774c_3464fc55",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1903905
      },
      "writtenOn": "2023-11-08T00:26:40Z",
      "side": 1,
      "message": "\u003e IIUC both the existing macros would continue to function exactly as they do today?\n\nThat\u0027s correct ðŸ˜Š\n\n\u003e They\u0027re extremely confusing errors to most people\n\nI think there is an improvement in error messages with this change -- there is clearer identification of whether the violation is for a boundary or for ownership, and where the violation comes from.\n\n\u003e most of the time they have no recourse to fix them other than adding an exception for certain paths\n\nI think this is well-addressed by the split of responsibilities in the new macros.  Say for (slightly inaccurate) example you want to add Settings (a product artifact) to generic_system.mk, and there is a dependency on libbinder_ndk (a system artifact).  Using require-no-new-artifacts-outside-path, you can add whatever system-based dependency to the system makefile (say, libbinder_ndk to base_system) and then whatever product-based artifact to the product makefile that depends on it (say, Settings to either base_product or generic_system). And then generic_system can use require-no-other-artifacts-inside-path to protect /system and /system_ext without complaining about the presence of Settings inside /product.\n\n\u003e It\u0027s also not really clear why we care about certain makefiles owning certain paths.\n\nI\u0027m not sure if this has a lot of value for Google internally beyond enforcing GSI boundaries (maybe it\u0027s not important to try to enforce boundaries for the \"fundamental\" product makefiles like base_system, media_product, handheld_vendor, etc), but I think it\u0027s a good framework in general for external entities working on custom SSI-based builds.\n\n\u003e There are also bugs that allow you to circumvent artifact path requirements, like b/299166571.\n\nUnfortunately I can\u0027t read the issue, but I think this change also makes artifact path requirements more robust and would expect it to be harder to circumvent with makefile-inheritance-based trickery.",
      "parentUuid": "d17af274_b76671ec",
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a22a2e29_d4a58b16",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1535516
      },
      "writtenOn": "2023-11-08T00:32:14Z",
      "side": 1,
      "message": "b/299166571 is that the files installed by adding modules to `PRODUCT_PACKAGES_SHIPPING_API_LEVEL_*` are not checked by artifact path requirements. I briefly tried to fix it in https://android-review.googlesource.com/c/platform/build/+/2737051/3",
      "parentUuid": "cb46774c_3464fc55",
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8778382b_69e44500",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1903905
      },
      "writtenOn": "2023-11-08T00:41:06Z",
      "side": 1,
      "message": "Interesting, thanks for the insight.  I might look into that as a follow-on, but I\u0027ll leave this change alone since it should have no compatibility impact to existing code, whereas fixing this bug would add new violations.",
      "parentUuid": "a22a2e29_d4a58b16",
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "689ddf1a_46f5b0a9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1060959
      },
      "writtenOn": "2023-11-08T10:09:16Z",
      "side": 1,
      "message": "\u003e It\u0027s also not really clear why we care about certain makefiles owning certain paths.\n\nIt\u0027s clear to me ðŸ˜Š I\u0027d be happy to give you more context about this Cole, ping me if you\u0027re interested.\n\nAside from the original intentions of this split, I think they would also serve as a good base for setting up \"real\" build targets for the various partitions with explicit deps (as opposed to the haphazard staging directory strategy).\n\n\u003e most of the time they have no recourse to fix them other than adding an exception for certain paths\n\nI don\u0027t agree. Our internal builds give a different error message (see `PRODUCT_ARTIFACT_PATH_REQUIREMENT_HINT`) that link to go/artifact-error, which gives more context and recommends reaching out to a mailing list for guidance if necessary (which many people have done). I\u0027m pretty confident the existence of these checks have kept the partition split in makefiles at a good level since it was implemented ~5 years ago. I don\u0027t want to think about what they would have looked like without these checks. They might not be perfect, but they\u0027re a lot better than nothing.",
      "parentUuid": "8778382b_69e44500",
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "08e113e3_c45018de",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1903905
      },
      "writtenOn": "2023-11-10T20:50:35Z",
      "side": 1,
      "message": "Hey folks, just wondering if there are any updates here?  Any followup needed from my end?",
      "parentUuid": "689ddf1a_46f5b0a9",
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3932e818_145ddb85",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1903905
      },
      "writtenOn": "2023-11-27T18:28:17Z",
      "side": 1,
      "message": "Gentle post-holiday ping ðŸ˜Š",
      "parentUuid": "08e113e3_c45018de",
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f39e0e81_a2d34370",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1535516
      },
      "writtenOn": "2023-11-28T01:00:53Z",
      "side": 1,
      "message": "Sorry for the slow review, I took a look at this some today, but I want to spend more time digging into it tomorrow.",
      "parentUuid": "3932e818_145ddb85",
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e0b7ecc8_ab08b612",
        "filename": "core/artifact_path_requirements.mk",
        "patchSetId": 3
      },
      "lineNbr": 35,
      "author": {
        "id": 1535516
      },
      "writtenOn": "2023-11-29T01:08:22Z",
      "side": 1,
      "message": "`PRODUCT_ENFORCE_ARTIFACT_PATH_REQUIREMENTS` is supposed to provide a global switch to turn off artifact path requirements for the whole product. Why are we making it per-makefile?",
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b58f9951_92f0a0da",
        "filename": "core/artifact_path_requirements.mk",
        "patchSetId": 3
      },
      "lineNbr": 35,
      "author": {
        "id": 1903905
      },
      "writtenOn": "2023-11-29T01:12:05Z",
      "side": 1,
      "message": "It is already per-makefile: https://cs.android.com/android/platform/superproject/+/master:build/make/core/product.mk;l\u003d290;drc\u003daa9a4a490783f114f224716526cae5c16e0d4a13",
      "parentUuid": "e0b7ecc8_ab08b612",
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4fec22df_571bc623",
        "filename": "core/artifact_path_requirements.mk",
        "patchSetId": 3
      },
      "lineNbr": 35,
      "author": {
        "id": 1535516
      },
      "writtenOn": "2023-11-29T01:16:00Z",
      "side": 1,
      "message": "It\u0027s a product variable, but the [previous implementation was just accessing it\u0027s final value](https://cs.android.com/android/platform/superproject/main/+/main:build/make/core/artifact_path_requirements.mk;l\u003d53;drc\u003dd8cde776070d0a2b592d5b53dac5c188b73a671b), not it\u0027s value at the point of intermediate makefiles.",
      "parentUuid": "b58f9951_92f0a0da",
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cd9a7190_1150b0d0",
        "filename": "core/artifact_path_requirements.mk",
        "patchSetId": 3
      },
      "lineNbr": 42,
      "author": {
        "id": 1535516
      },
      "writtenOn": "2023-11-29T01:08:22Z",
      "side": 1,
      "message": "Please document this function",
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "19073ca0_0a292c81",
        "filename": "core/artifact_path_requirements.mk",
        "patchSetId": 3
      },
      "lineNbr": 49,
      "author": {
        "id": 1535516
      },
      "writtenOn": "2023-11-28T01:00:53Z",
      "side": 1,
      "message": "isn\u0027t `_nmp_all_visited_parents` going to just be cleared immediately after this due to the recursive call?",
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a36e7696_c9f03599",
        "filename": "core/artifact_path_requirements.mk",
        "patchSetId": 3
      },
      "lineNbr": 49,
      "author": {
        "id": 1903905
      },
      "writtenOn": "2023-11-28T01:05:15Z",
      "side": 1,
      "message": "Ah yeah good catch, missed this in a refactor.",
      "parentUuid": "19073ca0_0a292c81",
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c1a174b3_2d8f6012",
        "filename": "core/artifact_path_requirements.mk",
        "patchSetId": 3
      },
      "lineNbr": 81,
      "author": {
        "id": 1535516
      },
      "writtenOn": "2023-11-29T01:08:22Z",
      "side": 1,
      "message": "This evaluating a variable without calling it is an interesting trick that I didn\u0027t know about before, but I think it would be clearer if we just always called variables that are used as functions. Especially in cases like this where you\u0027re mixing the trick with a standard call.\n\nSame in product.mk",
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "06fa154d_40ca4c52",
        "filename": "core/artifact_path_requirements.mk",
        "patchSetId": 3
      },
      "lineNbr": 81,
      "author": {
        "id": 1903905
      },
      "writtenOn": "2023-11-29T01:19:51Z",
      "side": 1,
      "message": "Very fair, will do!",
      "parentUuid": "c1a174b3_2d8f6012",
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2ebd9d5d_4e8c9ea4",
        "filename": "core/artifact_path_requirements.mk",
        "patchSetId": 3
      },
      "lineNbr": 83,
      "author": {
        "id": 1535516
      },
      "writtenOn": "2023-11-29T01:08:22Z",
      "side": 1,
      "message": "Is a \"derived product\" a child or parent product? What does \"override them away\" mean?",
      "range": {
        "startLine": 83,
        "startChar": 45,
        "endLine": 83,
        "endChar": 84
      },
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a35ca2af_de345c4f",
        "filename": "core/artifact_path_requirements.mk",
        "patchSetId": 3
      },
      "lineNbr": 83,
      "author": {
        "id": 1903905
      },
      "writtenOn": "2023-11-29T01:19:51Z",
      "side": 1,
      "message": "Derived \u003d\u003d child.  Imagine /system/FooStub.apk in base.mk and /system_ext/Foo.apk in derived.mk, where derived.mk has $(call require-no-new-artifacts-outside-path, /system_ext), and Foo overides FooStub -- now derived.mk and products that inherit it will not have /system/FooStub.apk in the system image, so having /system/FooStub.apk be a strict exception will cause a build error.\n\nBeyond replacing \"derived\" with \"child\", do you have suggestions on a better way to phrase this?",
      "parentUuid": "2ebd9d5d_4e8c9ea4",
      "range": {
        "startLine": 83,
        "startChar": 45,
        "endLine": 83,
        "endChar": 84
      },
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f2dba795_8eca1efc",
        "filename": "core/artifact_path_requirements.mk",
        "patchSetId": 3
      },
      "lineNbr": 148,
      "author": {
        "id": 1535516
      },
      "writtenOn": "2023-11-29T01:08:22Z",
      "side": 1,
      "message": "Similarly to `PRODUCT_ENFORCE_ARTIFACT_PATH_REQUIREMENTS`, this used to be a global variable. Simply changing it to be scoped won\u0027t work for existing makefiles like this one, that set it but don\u0027t call `require-artifacts-in-path`: https://cs.android.com/android/platform/superproject/main/+/main:build/make/target/product/runtime_libart.mk;l\u003d196;drc\u003dbf0c0e68568a2321d1b4c0e9170b31dcfc7cdb54",
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1ca2f878_c1485b84",
        "filename": "core/artifact_path_requirements.mk",
        "patchSetId": 3
      },
      "lineNbr": 148,
      "author": {
        "id": 1903905
      },
      "writtenOn": "2023-11-29T01:12:05Z",
      "side": 1,
      "message": "This is also already a per-product-makefile variable: https://cs.android.com/android/platform/superproject/+/master:build/make/core/product.mk;l\u003d294;drc\u003daa9a4a490783f114f224716526cae5c16e0d4a13",
      "parentUuid": "f2dba795_8eca1efc",
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "774ab538_184f63cb",
        "filename": "core/product.mk",
        "patchSetId": 3
      },
      "lineNbr": 534,
      "author": {
        "id": 1535516
      },
      "writtenOn": "2023-11-29T01:08:22Z",
      "side": 1,
      "message": "Is there a need for this functionality? This seems like it enables laziness instead of properly ensuring all your files, even from within inherited makefiles, are within your boundaries.",
      "revId": "a361aa1c39aab51d62816f34cfd93e0cd137cf83",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}