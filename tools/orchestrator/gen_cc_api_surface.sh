#!/bin/bash
set -euo pipefail

# Copyright (C) 2022 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# Script that reads output json of a Bazel cc_api_surface target and
# 1. copies contribution files to multi-tree out/
# 2. generates Android.bp file for each contributing library
#
# Arguments
#  $1: outer tree out directory
#  $2: Bazel label of the cc_api_surface
#  $3: inner_tree root

OUT_DIR="$1"
BAZEL_LABEL="$2"
INNER_TREE="$3"

# Load helper functions
source $(dirname "$0")/gen_api_surface_common.sh

# Generates an Android.bp file from a template
# Globals:
# Arguments:
#  $1: name of the stub library
#  $2: name of the api surface
#  $3: name of the symbol file
#  $4: first version
# Outputs:
#  Writes the substitued template to stdout
function generate_bp_from_template(){
  # TODO(spandandas): Prevent name collision of the headers module in consuming inner trees
  header_module_name="$1"_"$2"_headers
cat << EOF
// AUTOGENERATED: DO NOT EDIT
cc_stub_library {
  name: "$1",
  api_surface_name: "$2",
  symbol_file: "$3",
  first_version: "$4",
}

cc_library_headers {
  name: "$header_module_name",
  export_include_dirs: [
      "include",
  ],
}
EOF
}

# Determine output filepath from bazel label
api_surface_output_filepath=$(bazel_output_filepath "$INNER_TREE" "$BAZEL_LABEL")

# Read metadata from json
api_surface_name=$(jq -rc .name "$api_surface_output_filepath")
# Use -c compact output to enable iteration in a for loop
# Otherwise the for loop will split the JSON string along each newline char
api_contributions=$(jq -rc .contributions[] "$api_surface_output_filepath")

# Generate api surfaces into a temp directory
tmp=$(mktemp -t -d st.XXXXX)
# Loop over api_contribtions
# Warning: Do not use "$api_contributions" (i.e. with quotes). This will cause
# the iterator to interpret it as a raw string and not a sequence
for api_contribution in $api_contributions; do
  api_library_name=$(echo "$api_contribution" | jq -rc .name)
  first_version=$(echo "$api_contribution" | jq -rc .first_version)

  # Copy headers to $tmp/$api_library_name/include
  headers=$(echo "$api_contribution" | jq -rc .headers_filepath[])
  copy_files "$tmp"/"$api_library_name"/include "$INNER_TREE" "$headers"

  # Copy symbol_file to $tmp/$api_library_name
  symbol_file=$(echo "$api_contribution" | jq -rc .symbol_filepath)
  copy_files "$tmp"/"$api_library_name" "$INNER_TREE" "$symbol_file"

  # Generate Android.bp in $tmp/$api_library_name
  symbol_file_name=$(basename "$symbol_file")
  generate_bp_from_template "$api_library_name" "$api_surface_name" "$symbol_file_name" "$first_version" > "$tmp"/$api_library_name/Android.bp
done

# Copy api surfaces from temp to out directory
# This uses rsync --checksum so that copy operation is performed only if src !=
# dest
# # This ensures that inputs to ninja actions do not become dirty after every
# build orchestrator run
# Extraneous files should be deleted using --delete
# These extraneous files are likely api contributions that have been deleted
# since the previous run
mkdir -p "$OUT_DIR"/"$api_surface_name"
rsync --checksum --delete -r "$tmp"/ "$OUT_DIR"/"$api_surface_name"
