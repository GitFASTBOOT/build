//! codegenerated rust flag lib

use aconfig_storage_read_api::\{StorageFileType, get_mapped_storage_file, get_boolean_flag_value, get_package_offset};
use std::path::Path;
use std::io::Write;
use log::\{info, error, LevelFilter};

static STORAGE_MIGRATION_MARKER_FILE: &str =
    "/metadata/aconfig/storage_test_mission_1";
static MIGRATION_LOG_TAG: &str = "AconfigTestMission1";

/// flag provider
pub struct FlagProvider;

{{ if has_readwrite- }}
lazy_static::lazy_static! \{
{{ -for flag in template_flags }}
    {{ -if flag.readwrite }}
    /// flag value cache for {flag.name}
    static ref CACHED_{flag.name}: bool = flags_rust::GetServerConfigurableFlag(
        "aconfig_flags.{flag.device_config_namespace}",
        "{flag.device_config_flag}",
        "{flag.default_value}") == "true";
    {{ -endif }}
{{ -endfor }}
}
{{ -endif }}

impl FlagProvider \{

{{ for flag in template_flags }}
    /// query flag {flag.name}
    pub fn {flag.name}(&self) -> bool \{
        {{ -if flag.readwrite }}
        *CACHED_{flag.name}
        {{ -else }}
        {flag.default_value}
        {{ -endif }}
    }
{{ endfor }}

}

/// flag provider
pub static PROVIDER: FlagProvider = FlagProvider;

{{ for flag in template_flags }}
/// query flag {flag.name}
#[inline(always)]
{{ -if flag.readwrite }}
pub fn {flag.name}() -> bool \{
    PROVIDER.{flag.name}()
{{ -else }}
pub fn {flag.name}() -> bool \{
    {{ if not allow_instrumentation }}
    {flag.default_value}
    {{ else }}

    let result = {flag.default_value};
    if !Path::new(STORAGE_MIGRATION_MARKER_FILE).exists() \{
        return result;
    }

    // This will be called multiple times. Subsequent calls after the first
    // are noops.
    logger::init(
        logger::Config::default()
            .with_tag_on_device(MIGRATION_LOG_TAG)
            .with_max_level(LevelFilter::Info),
    );

    unsafe \{
        let package_map = match get_mapped_storage_file("{flag.container}", StorageFileType::PackageMap) \{
            Ok(file) => file,
            Err(err) => \{
                error!("failed to read flag '{flag.name}': \{}", err);
                return result;
            }
        };
        let package_offset = match get_package_offset(&package_map, "{package}") \{
            Ok(Some(offset)) => offset,
            Ok(None) => \{
                error!("failed to read flag '{flag.name}', not found in package map");
                return result;
            },
            Err(err) => \{
                error!("failed to read flag '{flag.name}': \{}", err);
                return result;
            }
        };
        let flag_val_map = match get_mapped_storage_file("{flag.container}", StorageFileType::FlagVal) \{
            Ok(val_map) => val_map,
            Err(err) => \{
                error!("failed to read flag '{flag.name}': \{}", err);
                return result;
            }
        };
        let value = match get_boolean_flag_value(&flag_val_map, {flag.flag_offset} + package_offset.boolean_offset) \{
            Ok(val) => val,
            Err(err) => \{
                error!("failed to read flag '{flag.name}': \{}", err);
                return result;
            }
        };

        if result != value \{
            error!("error: flag mismatch for '{flag.name}'. Legacy storage was \{result}, new storage was \{value}")
        } else \{
            let default_value = {flag.default_value};
            info!("success! flag '{flag.name}' contained correct value. Legacy storage was \{default_value}, new storage was \{value}")
        }
    }

    result
    {{ endif }}
{{ -endif }}
}
{{ endfor }}
