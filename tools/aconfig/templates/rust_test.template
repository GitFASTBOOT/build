//! codegenerated rust flag lib

use std::collections::HashMap;
use std::sync::Mutex;
use once_cell::sync::Lazy;

/// flag provider
struct FlagProvider \{
    overrides: HashMap<&'static str, bool>,
}

impl FlagProvider \{
    {{ for flag in template_flags }}
    /// query flag {flag.name}
    pub fn {flag.name}(&self) -> bool \{
        self.overrides.get("{flag.name}").copied().unwrap_or(
        {{ if flag.readwrite -}}
          flags_rust::GetServerConfigurableFlag(
            "{flag.device_config_namespace}",
            "{flag.device_config_flag}",
            "{flag.default_value}") == "true"
        {{ -else- }}
           {flag.default_value}
        {{ -endif }}
        )
    }

    /// set flag {flag.name}
    pub fn set_{flag.name}(&mut self, val: bool) \{
        self.overrides.insert("{flag.name}", val);
    }
    {{ endfor }}

    /// clear all flag overrides
    pub fn reset_flags(&mut self) \{
        self.overrides.clear();
    }
}

/// flag provider
static PROVIDER: Lazy<Mutex<FlagProvider>> = Lazy::new(|| \{
    let provider = FlagProvider\{
        overrides: HashMap::new(),
    };
    Mutex::new(provider)
});

{{ for flag in template_flags }}
/// query flag {flag.name}
#[inline(always)]
pub fn {flag.name}() -> bool \{
    PROVIDER.lock().unwrap().{flag.name}()
}

/// set flag {flag.name}
#[inline(always)]
pub fn set_{flag.name}(val: bool) \{
    PROVIDER.lock().unwrap().set_{flag.name}(val);
}
{{ endfor }}

/// clear all flag override
pub fn reset_flags() \{
    PROVIDER.lock().unwrap().reset_flags()
}
