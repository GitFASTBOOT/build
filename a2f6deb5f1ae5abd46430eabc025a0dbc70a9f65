{
  "comments": [
    {
      "key": {
        "uuid": "b012530c_363b9604",
        "filename": "core/combo/TARGET_linux-arm.mk",
        "patchSetId": 2
      },
      "lineNbr": 167,
      "author": {
        "id": 1003981
      },
      "writtenOn": "2014-09-23T00:45:58Z",
      "side": 1,
      "message": "You need the \t$(combo_2nd_arch_prefix) prefix, so it works in multilib build.",
      "revId": "a2f6deb5f1ae5abd46430eabc025a0dbc70a9f65",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d01507f5_9a928d45",
        "filename": "core/combo/TARGET_linux-arm.mk",
        "patchSetId": 2
      },
      "lineNbr": 216,
      "author": {
        "id": 1003981
      },
      "writtenOn": "2014-09-23T00:45:58Z",
      "side": 1,
      "message": "This won\u0027t work in multlib build.\nYou need to turn it into a target-specific variable (like the PRIVATE_TARGET_LIBATOMIC). Or can we merge PRIVATE_TARGET_LIBATOMIC, PRIVATE_TARGET_LIBGCOV and PRIVATE_TARGET_LIBGCC to a single PRIVATE_ variable?",
      "revId": "a2f6deb5f1ae5abd46430eabc025a0dbc70a9f65",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "50b7574c_5062ac8f",
        "filename": "core/combo/TARGET_linux-arm.mk",
        "patchSetId": 2
      },
      "lineNbr": 216,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2014-09-23T16:14:56Z",
      "side": 1,
      "message": "Merging them into a PRIVATE_BUILTINS would be nice, but that\u0027s probably a job for another patch, since that also will require us being consistent with the order in which libgcc is added (currently different for platform builds and unbundled). I think unbundled actually does the better thing by adding libgcc before all of the dependent libraries (since that ensures that no binary ever expects to receive libgcc symbols from libc).",
      "parentUuid": "d01507f5_9a928d45",
      "revId": "a2f6deb5f1ae5abd46430eabc025a0dbc70a9f65",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7021bb30_82a03b1a",
        "filename": "core/target_test_internal.mk",
        "patchSetId": 2
      },
      "lineNbr": 27,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2014-09-22T23:11:21Z",
      "side": 1,
      "message": "Using a static library makes every test in the tree sensitive to libstdc++ being built with coverage information. Is there any downside to using a shared library?",
      "revId": "a2f6deb5f1ae5abd46430eabc025a0dbc70a9f65",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b012530c_d69ce258",
        "filename": "core/target_test_internal.mk",
        "patchSetId": 2
      },
      "lineNbr": 27,
      "author": {
        "id": 1003981
      },
      "writtenOn": "2014-09-23T00:13:37Z",
      "side": 1,
      "message": "I remember this is a hack to fix bionic-unit-tests-static build, see https://b.corp.google.com/issue?id\u003d13643367#ISSUE_HistoryHeader9 . Not sure if moving to libstdc++.so would break the build.",
      "parentUuid": "7021bb30_82a03b1a",
      "revId": "a2f6deb5f1ae5abd46430eabc025a0dbc70a9f65",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7021bb30_e55b412e",
        "filename": "core/target_test_internal.mk",
        "patchSetId": 2
      },
      "lineNbr": 27,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2014-09-23T00:16:56Z",
      "side": 1,
      "message": "Ah, okay. I think we no longer have this issue because libc has that symbol itself now, but I\u0027m still re-verifying this.",
      "parentUuid": "b012530c_d69ce258",
      "revId": "a2f6deb5f1ae5abd46430eabc025a0dbc70a9f65",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}