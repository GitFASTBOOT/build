{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "0ba4284e_5e342f30",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1416371
      },
      "writtenOn": "2023-05-24T19:46:56Z",
      "side": 1,
      "message": "How do we forsee someone using the Rust code generated here? It may be worth adding a module type similar to `rust_protobuf` or `rust_bindgen` to automatically produce a crate out of a configuration file.\n\nIf you do this, you may also want to force it to be rlib-only in order to avoid having a whole `.so` just to encode this information.\n\nAs a note, we currently advise against `include!` in 1p source, so if you feel you need to tell users to do that, please let me know and I\u0027ll try to help you figure out how we can avoid that.",
      "revId": "75cd08882bd9d860748dc42260cdc290d45ea21f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "05987d93_42ec937a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1937565
      },
      "writtenOn": "2023-05-25T11:10:58Z",
      "side": 1,
      "message": "See go/android-flag-cookbook for intended usage. Focus ATM is Java but Rust should be similar: aconfig will convert its input into a language suitable library with functions corresponding to each flag; modules link against that library. The canonical way to access flag\u0027s values is to call the generated function; no protobuf parsing takes place in the client code.\n\nRegarding `include!`: I\u0027m missing something here: users of aconfig\u0027s autogenerated code will not use include!s. Do you refer to this CL\u0027s use of `include!`? I would prefer to keep the include!s for reading the test data -- the same input files will be reused in integration tests, where aconfig will parse them as part of building those tests.",
      "parentUuid": "0ba4284e_5e342f30",
      "revId": "75cd08882bd9d860748dc42260cdc290d45ea21f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0e4ec27e_e1d3963f",
        "filename": "tools/aconfig/templates/rust.template",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1416371
      },
      "writtenOn": "2023-05-24T19:46:56Z",
      "side": 1,
      "message": "If it weren\u0027t for the C++ and Java codegen already using tinytemplate, I\u0027d suggest that you use `syn` and `quote` for codegen instead - it\u0027d allow you to avoid error classes like accidentally using reserved words as identifiers.",
      "revId": "75cd08882bd9d860748dc42260cdc290d45ea21f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c917fdcb_7b388922",
        "filename": "tools/aconfig/templates/rust.template",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1937565
      },
      "writtenOn": "2023-05-25T11:10:58Z",
      "side": 1,
      "message": "Thanks for the suggestions.\n\nI have no love for tinytemplate. The code aconfig generates is so simple that I would have preferred to start with `println!` but in the interest of getting something ready for the build system to hook into I\u0027m ok with the crate for now.\n\ntinytemplate is too limited, and we don\u0027t have sufficient text outside the placeholders that I feel tinytemplate adds any value; only complexity. `syn` and `quote` are interesting options but again, if we can keep the code sufficiently simply, `println!` may be the best choice.\n\nThe auto-generated code is still undergoing design changes; I\u0027m waiting for the dust to settle until I make my move.",
      "parentUuid": "0e4ec27e_e1d3963f",
      "revId": "75cd08882bd9d860748dc42260cdc290d45ea21f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fa41a289_0e6b28d5",
        "filename": "tools/aconfig/templates/rust.template",
        "patchSetId": 1
      },
      "lineNbr": 2,
      "author": {
        "id": 1416371
      },
      "writtenOn": "2023-05-24T19:46:56Z",
      "side": 1,
      "message": "#[inline(always)]",
      "revId": "75cd08882bd9d860748dc42260cdc290d45ea21f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "85c1f21b_5ba761d9",
        "filename": "tools/aconfig/templates/rust.template",
        "patchSetId": 1
      },
      "lineNbr": 2,
      "author": {
        "id": 1416371
      },
      "writtenOn": "2023-05-24T19:46:56Z",
      "side": 1,
      "message": "You may want to use `r#{parsed_flag.fn_name}` in order to avoid situations where fn_name happens to be a rust keyword.",
      "revId": "75cd08882bd9d860748dc42260cdc290d45ea21f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "72f73565_41d6dce2",
        "filename": "tools/aconfig/templates/rust.template",
        "patchSetId": 1
      },
      "lineNbr": 2,
      "author": {
        "id": 1937565
      },
      "writtenOn": "2023-05-25T11:10:58Z",
      "side": 1,
      "message": "TIL r# works with identifiers!",
      "parentUuid": "85c1f21b_5ba761d9",
      "revId": "75cd08882bd9d860748dc42260cdc290d45ea21f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "da0081e0_13aef619",
        "filename": "tools/aconfig/templates/rust.template",
        "patchSetId": 1
      },
      "lineNbr": 2,
      "author": {
        "id": 1937565
      },
      "writtenOn": "2023-05-25T11:10:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fa41a289_0e6b28d5",
      "revId": "75cd08882bd9d860748dc42260cdc290d45ea21f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f90c2932_9aa66fad",
        "filename": "tools/aconfig/templates/rust.template",
        "patchSetId": 1
      },
      "lineNbr": 3,
      "author": {
        "id": 1416371
      },
      "writtenOn": "2023-05-24T19:46:56Z",
      "side": 1,
      "message": "Do we want to make it a const fn if either read_only mode is enabled?\n\nThe advantage of this is that you could change static initializers and similar things based on the flag.\nThe disadvantage would bet that if someone used it in this way, you\u0027d only ever be able to flip the flag between static configurations, you couldn\u0027t use a dynamic configuration.",
      "revId": "75cd08882bd9d860748dc42260cdc290d45ea21f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "aea17e07_1ea18d85",
        "filename": "tools/aconfig/templates/rust.template",
        "patchSetId": 1
      },
      "lineNbr": 3,
      "author": {
        "id": 1937565
      },
      "writtenOn": "2023-05-25T11:10:58Z",
      "side": 1,
      "message": "I like the idea of const fn, but I want to reserve the freedom to change the implementation from a simple `false` to something that allows unit tests to set the value. Discussions are currently ongoing and until those have settled I can\u0027t say if we will need this option for read_only flags.\n\nIf I were to add const today, removing it tomorrow would be a breaking change, so I\u0027d rather hold off for the time being.\n\nCreated b/284270369 as a reminder to revisit this once the Java test has been decided.",
      "parentUuid": "f90c2932_9aa66fad",
      "revId": "75cd08882bd9d860748dc42260cdc290d45ea21f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}