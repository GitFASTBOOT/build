{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "005d863a_dda1e15a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1066075
      },
      "writtenOn": "2021-11-09T12:02:20Z",
      "side": 1,
      "message": "In Joe\u0027s absence, I\u0027ll try review this.",
      "revId": "ec2be80364510b9de9614633b67dc114a6abe718",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9841ccc3_bb6725f5",
        "filename": "tools/scripts/update-api.sh",
        "patchSetId": 8
      },
      "lineNbr": 48,
      "author": {
        "id": 1066075
      },
      "writtenOn": "2021-11-09T12:02:20Z",
      "side": 1,
      "message": "This requires the Ninja files to be present, doesn\u0027t it? (i.e. it doesn\u0027t work on a clean checkout)\n\nIIUC that this does is to call \"m \u003ctargets on the command line\u003e\" then digs out the names of the update API scripts those targets create, then executes them. Would it be possible to instead standardize on the path names of the update API scripts so that the Ninja invocation in line 29 is not required and do this here:\n\nm \"$@\"\nfor target in \"$@\"; do \n  update_script\u003d$(update_script_from_target $target)\n  \"$update_script\"\ndone\n\nfunction update_script_from_target() {\n  echo $1 | sed \u0027s/.../.../\u0027  # Some simple regular expression\n}\n\nOr, even better: if you can come up with an algorithm to convert the target names to input/output API file names, you can dispense with the helper scripts altogether and let the Ninja files call this script with the appropriate arguments directly, something like this (excuse my Make):\n\n\nfoo-update-current-api: new-api-file.txt\n  echo \"Dumping current API to new-api-file.txt\"\n  \nlegacy-foo-update-current-api: foo-update-current-api\n  echo \"This will go away, run build/make/tools/scripts/update-api.sh $^ instead\"\n  build/make/tools/scripts/update-api.sh --do-not-run-m $^\n  \n  \nthen in update-api.sh:\n\ntarget\u003d$1\noutput_api_file \u003d $(new_api_file $target)\nsource_api_fie \u003d $(source_api_file $target)\ncp -f $soutput_api_file $source_api_file\n\n(--do-not-run-m is so that update-api.sh does not call \"m\" thus resulting in an infinite loop)",
      "range": {
        "startLine": 48,
        "startChar": 2,
        "endLine": 48,
        "endChar": 52
      },
      "revId": "ec2be80364510b9de9614633b67dc114a6abe718",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e2c0382e_266499ed",
        "filename": "tools/scripts/update-api.sh",
        "patchSetId": 8
      },
      "lineNbr": 48,
      "author": {
        "id": 1878380
      },
      "writtenOn": "2021-11-10T22:58:13Z",
      "side": 1,
      "message": "\u003e This requires the Ninja files to be present, doesn\u0027t it? (i.e. it doesn\u0027t work on a clean checkout)\nThats a great catch, I had not realized about this circular dependency on clean checkouts.\n\n\n\u003e Would it be possible to instead standardize on the path names of the update API scripts so that the Ninja invocation in line 29 is\nI was thinking about that, but felt that this might the implementation a little fragile. As an example, if we refactor the update-api stuff in build/soong, it might affect update-api.sh in build/make \n\n\n\u003e m \"$@\"\nRunning the phony update-api targets directly would print the warning message to use tool/scripts/update-api.sh (even though you are running tools/scripts/update-api.sh!). Hence I thought I would build the underlying `update_script_from_target` instead.\nAs you mentioned, this will not work in a clean checkout as of now\n\n\n\u003e let the Ninja files call this script with the appropriate arguments directly\nI really like this idea. This provides continuity between updating the API from within the build and from outside the build, using the same entrypoint.\n\n\n\u003e if you can come up with an algorithm to convert the target names to input/output API file names\nIs this idea different from the mapping of *update-api --\u003e *update-api-script via something like this which you suggested previously\n```\nfunction update_script_from_target() {\n  echo $1 | sed \u0027s/.../.../\u0027  # Some simple regular expression\n}\n```",
      "parentUuid": "9841ccc3_bb6725f5",
      "range": {
        "startLine": 48,
        "startChar": 2,
        "endLine": 48,
        "endChar": 52
      },
      "revId": "ec2be80364510b9de9614633b67dc114a6abe718",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd157965_cd5cc0ec",
        "filename": "tools/scripts/update-api.sh",
        "patchSetId": 8
      },
      "lineNbr": 48,
      "author": {
        "id": 1066075
      },
      "writtenOn": "2021-11-11T08:16:58Z",
      "side": 1,
      "message": "\u003e \u003e This requires the Ninja files to be present, doesn\u0027t it? (i.e. it doesn\u0027t work on a clean checkout)\n\u003e Thats a great catch, I had not realized about this circular dependency on clean checkouts.\n\u003e \n\u003e \n\u003e \u003e Would it be possible to instead standardize on the path names of the update API scripts so that the Ninja invocation in line 29 is\n\u003e I was thinking about that, but felt that this might the implementation a little fragile. As an example, if we refactor the update-api stuff in build/soong, it might affect update-api.sh in build/make \nYeah, that\u0027s the ugly part of it. Weigh that against the complexity of transmitting the information in a \"principled\" way. In google3, we have this thingy where you can have comments that make the linter complain if you change one line of code but not another.\n\n\n\u003e \n\u003e \n\u003e \u003e m \"$@\"\n\u003e Running the phony update-api targets directly would print the warning message to use tool/scripts/update-api.sh (even though you are running tools/scripts/update-api.sh!). Hence I thought I would build the underlying `update_script_from_target` instead.\n\u003e As you mentioned, this will not work in a clean checkout as of now\n\u003e \n\u003e \n\u003e \u003e let the Ninja files call this script with the appropriate arguments directly\n\u003e I really like this idea. This provides continuity between updating the API from within the build and from outside the build, using the same entrypoint.\n:thumbs up\n\n\u003e \n\u003e \n\u003e \u003e if you can come up with an algorithm to convert the target names to input/output API file names\n\u003e Is this idea different from the mapping of *update-api --\u003e *update-api-script via something like this which you suggested previously\n\u003e ```\n\u003e function update_script_from_target() {\n\u003e   echo $1 | sed \u0027s/.../.../\u0027  # Some simple regular expression\n\u003e }\n\u003e ```\nIt\u0027s mostly the same, except that one is about the public API .txt files under $OUT_DIR that are copied to the source tree and the other is about the update scripts.\n\nI think there are two options:\n\nA. Put the .txt files under $OUT_DIR at some very simple path (if Soong/Make can do that), e.g. out/soong/apitxts/\u003cfile\u003e and put in scary comments to both places where that is specified and a test case\n\nB. Use the trick to call \"ninja -t query\" above tot determine them. Then it would look like this:\n\n1. User calls \"update_api.sh foobar\"\n2. update_api.sh calls \"m foobar-txt-files\"\n3. update_api.sh calls \"ninja -t query foobar-txt-files\" and digs the name of the .txt file under $OUT_DIR by shell hackery and under the source tree... dunno, either by transforming the path of the .txt file under $OUT_DIR or by reading a file that Ninja conveniently writes somewhere in a dependency of foobar-txt-files?\n4. update_api.sh copies the files to the source tree\n\nOr, with the legacy method:\n1. User calls \"m foobar-update-current-api\"\n2. foobar-update-current-api has a dependency on foobar-txt-files\n3. foobar-update-current-api calls update_api.sh --do_not_run_m foobar\n4. update_api.sh emits a big fat warning about being called the wrong way\n5. update_api.sh does the same thing as when called directly except without the \"m\" call (i.e. steps (3) and (4) above). This implies that \"ninja -t query -f \u003cfile\u003e\" works also when called from \"ninja -f \u003cthe same file\u003e\", but I hope it does?\n\n...or just make the legacy method error out and print a command for the user to execute. That\u0027s way less headache.",
      "parentUuid": "e2c0382e_266499ed",
      "range": {
        "startLine": 48,
        "startChar": 2,
        "endLine": 48,
        "endChar": 52
      },
      "revId": "ec2be80364510b9de9614633b67dc114a6abe718",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "754fd813_094e93c2",
        "filename": "tools/scripts/update-api.sh",
        "patchSetId": 8
      },
      "lineNbr": 48,
      "author": {
        "id": 1878380
      },
      "writtenOn": "2021-11-15T04:56:34Z",
      "side": 1,
      "message": "\u003e I think there are two options:\n\u003e A. Put the .txt files under $OUT_DIR at some very simple path (if Soong/Make can \u003e do that), e.g. out/soong/apitxts/\u003cfile\u003e and put in scary comments to both places \u003e where that is specified and a test case\n\u003e B. Use the trick to call \"ninja -t query\" above tot determine them. Then it would \u003e look like this: \n\nI am leaning towards Option A, albeit using a generated shell script as the interface between the build system and update-api.sh, instead of the txt files themselves. A generated script will look something like below, and extracting out the path of 1 .sh script is less complex that extracting the paths of 4 .txt file\n```\ncp out/soong/\u003c\u003e/current.txt pacakges/\u003c\u003e/current.txt\ncp out/soong/\u003c\u003e/removed.txt pacakges/\u003c\u003e/removed.txt\n```\n\nThen we can run the script directly during the build without using build/tools/scripts/update-api.sh\n```\nlegacy-foo-update-current-api: foo-update-current-api.sh\n  /bin/bash $^ \u0026\u0026 echo warning\n```\n\n\n\u003e ..or just make the legacy method error out and print a command for the user to\n\u003e execute. That\u0027s way less headache.\nI think that\u0027s the end goal. For the initial rollout, we want to retain the same workflow for devs. The only difference being a warning message gets printed to the screen",
      "parentUuid": "fd157965_cd5cc0ec",
      "range": {
        "startLine": 48,
        "startChar": 2,
        "endLine": 48,
        "endChar": 52
      },
      "revId": "ec2be80364510b9de9614633b67dc114a6abe718",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6d162e67_21d4cf3a",
        "filename": "tools/scripts/update-api.sh",
        "patchSetId": 8
      },
      "lineNbr": 48,
      "author": {
        "id": 1066075
      },
      "writtenOn": "2021-11-15T09:46:22Z",
      "side": 1,
      "message": "\u003e \u003e I think there are two options:\n\u003e \u003e A. Put the .txt files under $OUT_DIR at some very simple path (if Soong/Make can \u003e do that), e.g. out/soong/apitxts/\u003cfile\u003e and put in scary comments to both places \u003e where that is specified and a test case\n\u003e \u003e B. Use the trick to call \"ninja -t query\" above tot determine them. Then it would \u003e look like this: \n\u003e \n\u003e I am leaning towards Option A, albeit using a generated shell script as the interface between the build system and update-api.sh, instead of the txt files themselves. A generated script will look something like below, and extracting out the path of 1 .sh script is less complex that extracting the paths of 4 .txt file\n\u003e ```\n\u003e cp out/soong/\u003c\u003e/current.txt pacakges/\u003c\u003e/current.txt\n\u003e cp out/soong/\u003c\u003e/removed.txt pacakges/\u003c\u003e/removed.txt\n\u003e ```\nI\u0027m fine with this, but why is the shell script needed in this case? Soong can just as well generate the .txt files with the simple path and then you avoid the Shell-quoted-in-Ninja-quoted-in-Soong issue and have one fewer step to understand. IOW, in the process:\n\n1. update_api.sh calls m\n2. m results in the .txt file being at a \"guessable\" location\n3. update_api.sh copies the .txt file from the \"guessable\" location to the source tree\n\nthe shell script isn\u0027t needed, is it?\n\n\u003e \n\u003e Then we can run the script directly during the build without using build/tools/scripts/update-api.sh\n\u003e ```\n\u003e legacy-foo-update-current-api: foo-update-current-api.sh\n\u003e   /bin/bash $^ \u0026\u0026 echo warning\n\u003e ```\n\u003e \n\u003e \n\u003e \u003e ..or just make the legacy method error out and print a command for the user to\n\u003e \u003e execute. That\u0027s way less headache.\n\u003e I think that\u0027s the end goal. For the initial rollout, we want to retain the same workflow for devs. The only difference being a warning message gets printed to the screen\nYeah, the hidden assumption behind the \"error message\" plan was we don\u0027t need this step. I don\u0027t know how politically feasible that is, though.",
      "parentUuid": "754fd813_094e93c2",
      "range": {
        "startLine": 48,
        "startChar": 2,
        "endLine": 48,
        "endChar": 52
      },
      "revId": "ec2be80364510b9de9614633b67dc114a6abe718",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "955d7d18_c778c949",
        "filename": "tools/scripts/update-api.sh",
        "patchSetId": 8
      },
      "lineNbr": 48,
      "author": {
        "id": 1878380
      },
      "writtenOn": "2021-11-16T03:28:05Z",
      "side": 1,
      "message": "\u003e the shell script isn\u0027t needed, is it?\nThe shell script is useful for step 3, i.e. copies the .txt file from the \"guessable\" location to the source tree.\nupdate_api.sh does not know the target location in the source tree for the copy operation (usually it is something like pacakges/modules/../current.txt, but can vary). We can probably get this information in update-api.sh by using module-info.json, but I think hiding it behind a script dynamically generated by Soong provides for a good abstraction\n\n\n\u003e Yeah, the hidden assumption behind the \"error message\" plan was we don\u0027t need this step. I don\u0027t know how politically feasible that is, though.\nThis will eventually become a hard failure, but probably not right now.",
      "parentUuid": "6d162e67_21d4cf3a",
      "range": {
        "startLine": 48,
        "startChar": 2,
        "endLine": 48,
        "endChar": 52
      },
      "revId": "ec2be80364510b9de9614633b67dc114a6abe718",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}